{
  "_args": [
    [
      {
        "raw": "redux-socket.io@^1.4.0",
        "scope": null,
        "escapedName": "redux-socket.io",
        "name": "redux-socket.io",
        "rawSpec": "^1.4.0",
        "spec": ">=1.4.0 <2.0.0",
        "type": "range"
      },
      "/Applications/dev/Public/carTaxi_booking_app"
    ]
  ],
  "_from": "redux-socket.io@>=1.4.0 <2.0.0",
  "_id": "redux-socket.io@1.4.0",
  "_inCache": true,
  "_location": "/redux-socket.io",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/redux-socket.io-1.4.0.tgz_1491979896908_0.7622172667179257"
  },
  "_npmUser": {
    "name": "itaylor",
    "email": "ian.b.taylor@gmail.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "redux-socket.io@^1.4.0",
    "scope": null,
    "escapedName": "redux-socket.io",
    "name": "redux-socket.io",
    "rawSpec": "^1.4.0",
    "spec": ">=1.4.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/redux-socket.io/-/redux-socket.io-1.4.0.tgz",
  "_shasum": "28f5f8c47011bce809e2ab760f54891521219b54",
  "_shrinkwrap": null,
  "_spec": "redux-socket.io@^1.4.0",
  "_where": "/Applications/dev/Public/carTaxi_booking_app",
  "author": {
    "name": "ian.b.taylor@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/itaylor/redux-socket.io/issues"
  },
  "dependencies": {},
  "description": "An opinionated connector between socket.io and redux",
  "devDependencies": {
    "babel-eslint": "^7.0.0",
    "babel-preset-es2015": "^6.5.0",
    "babel-register": "^6.5.2",
    "eslint": "^3.8.1",
    "eslint-config-airbnb": "^12.0.0",
    "eslint-plugin-babel": "^3.1.0",
    "eslint-plugin-import": "^2.2.0",
    "eslint-plugin-react": "^6.4.1",
    "expect": "^1.14.0",
    "gulp": "^3.9.0",
    "gulp-babel": "^6.1.2",
    "mocha": "^3.1.2",
    "redux": "^3.0.3"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "28f5f8c47011bce809e2ab760f54891521219b54",
    "tarball": "https://registry.npmjs.org/redux-socket.io/-/redux-socket.io-1.4.0.tgz"
  },
  "gitHead": "ab08e5c73c6b95bf63efb49028d18609c68b5834",
  "homepage": "https://github.com/itaylor/redux-socket.io#readme",
  "keywords": [
    "redux",
    "middleware",
    "socket.io",
    "action"
  ],
  "license": "MIT",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "itaylor",
      "email": "ian.b.taylor@gmail.com"
    }
  ],
  "name": "redux-socket.io",
  "optionalDependencies": {},
  "readme": "# redux-socket.io\nAn opinionated connector between socket.io and redux.\n\nPhilosophy\n-------------\nSocket.io client->server messages should should be sent by dispatching actions to redux's store, where the action is the payload.  Socket.io server->client messages should be dispatched as actions when received.\n\nHow to use\n-------------\n### Installation\n```\nnpm install --save redux-socket.io\n```\n\n### Example usage\nThis will create a middleware that sends actions to the server when the action type starts with \"server/\".\nWhen the socket.io socket receives a message of type 'action', it will dispatch the action to the store.\n\nThe result of running this code from the client is a request to the server and a response from the server, both of\nwhich go through the redux store's dispatch method.\n\nClient side:\n```js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSocketIoMiddleware from 'redux-socket.io';\nimport io from 'socket.io-client';\nlet socket = io('http://localhost:3000');\nlet socketIoMiddleware = createSocketIoMiddleware(socket, \"server/\");\nfunction reducer(state = {}, action){\n  switch(action.type){\n    case 'message':\n      return Object.assign({}, {message:action.data});\n    default:\n      return state;\n  }\n}\nlet store = applyMiddleware(socketIoMiddleware)(createStore)(reducer);\nstore.subscribe(()=>{\n  console.log('new client state', store.getState());\n});\nstore.dispatch({type:'server/hello', data:'Hello!'});\n```\n\nServer side:\n```js\nvar http = require('http');\nvar server = http.createServer();\nvar socket_io = require('socket.io');\nserver.listen(3000);\nvar io = socket_io();\nio.attach(server);\nio.on('connection', function(socket){\n  console.log(\"Socket connected: \" + socket.id);\n  socket.on('action', (action) => {\n    if(action.type === 'server/hello'){\n      console.log('Got hello data!', action.data);\n      socket.emit('action', {type:'message', data:'good day!'});\n    }\n  });\n});\n```\n\n## Allowed criteria for action matching ##\nWhen you create this middleware, you can configure how it detects that a given action should be sent to socket.io.\nThis is done with the second parameter to `createSocketIoMiddleware`.\n\nYou can pass either a prefix string that will be matched against the action.type:\n```js\nlet socketIoMiddleware = createSocketIoMiddleware(socket, 'server/');\n```\nAn array of strings that will will be used as allowed prefixes:\n```js\nlet socketIoMiddleware = createSocketIoMiddleware(socket, [ 'post/', 'get/' ]);\n```\nOr a function that returns a truthy value if the action should be sent to socket.io:\n```js\nlet socketIoMiddleware = createSocketIoMiddleware(socket, (type, action) => action.io);\n```\n\n## Advanced usage ##\nThe default behavior is an \"optimistic\" update mode, where if an action matches the criteria you provided when you created the socket.io middleware, the middleware calls `socket.emit('action', action)` and then passes the action to the next middleware in the chain.\n\nIf you want to change this behavior, you can provide your own execute function that allows you to decide what to do with the action that matched your criteria.\n\nYou do this by providing a `function (action, emit, next, dispatch)` as the `execute` property of the third parameter of `createSocketIoMiddleware`\n\n### Example execute functions: ###\nThis is equivalent to the default execute function, so this is what will happen if you don't override it.  Use something like this if you want optimistic updates of your state, where the action you dispatch goes both to the server and to the redux reducers.\n```js\nimport createSocketIoMiddleware from 'redux-socket.io';\nfunction optimisticExecute(action, emit, next, dispatch) {\n  emit('action', action);\n  next(action);\n}\nlet socketIoMiddleware = createSocketIoMiddleware(socket, \"server/\", { execute: optimisticExecute });\n```\n\n\nHere's a function that would make the middleware swallow all the actions that matched the criteria and not allow them to continue down the middleware chain to the reducers.  This is easily used to make \"pessimistic\" updates of your state, by having the server respond by sending back an action type of the same type it was sent.\n```js\nimport createSocketIoMiddleware from 'redux-socket.io';\nfunction pessimisticExecute(action, emit, next, dispatch) {\n  emit('action', action);\n}\nlet socketIoMiddleware = createSocketIoMiddleware(socket, \"server/\", { execute: pessimisticExecute });\n```\n\nHere's a function that would make the middleware dispatch an alternate action that could be used in a scenario where you want the optimistic updates to be very explicit.  Here you would have actions of type `server/<actionName>` sent to the server, and also have another action `optimistic/<actionName>` dispatched as well with the same content.\n\n```js\nimport createSocketIoMiddleware from 'redux-socket.io';\nfunction optimisticExecute(action, emit, next, dispatch) {\n  emit('action', action);\n  const optimisticAction = {\n    ...action,\n    type: 'optimistic/' action.type.split('/')[1];\n  }\n  dispatch(optimisticAction);\n}\nlet socketIoMiddleware = createSocketIoMiddleware(socket, \"server/\", { execute: optimisticExecute });\n```\n\n### MIT License\nCopyright (c) 2015-2016 Ian Taylor\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/itaylor/redux-socket.io.git"
  },
  "scripts": {
    "build": "gulp",
    "lint": "eslint src/*.js test/*.js",
    "test": "npm run lint && npm run build && mocha --ui tdd --compilers js:babel-register"
  },
  "version": "1.4.0"
}
